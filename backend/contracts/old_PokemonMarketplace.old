// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

enum TokenType { ERC721, ERC1155 }
enum Status { UNSET, CREATED, COMPLETED, CANCELLED }

struct Listing {
    uint256 listingId;
    address listingCreator;
    address assetContract;
    uint256 tokenId;
    uint256 quantity;
    address currency;
    uint256 pricePerToken;
    uint128 startTimestamp;
    uint128 endTimestamp;
    bool reserved;
    TokenType tokenType;
    Status status;
}

struct ListingParameters {
    address assetContract;
    uint256 tokenId;
    uint256 quantity;
    address currency;
    uint256 pricePerToken;
    uint128 startTimestamp;
    uint128 endTimestamp;
    bool reserved;
}

/**
 * @title PokemonMarketplace
 * @dev A marketplace for trading Pokemon NFTs
 */
contract PokemonMarketplace is ReentrancyGuard, Ownable {
    // Native token address constant
    address public constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    
    uint256 private _tokenIds;
    uint256 private _itemsSold;
    uint256 private _auctionIds;
    
    // Fee percentage in basis points (0.1% = 10, 1% = 100, 10% = 1000)
    uint256 public marketplaceFee = 250; // 2.5%
    
    // Emergency stop
    bool public contractPaused = false;
    
    enum ListingType { FixedPrice, Auction }
    
    struct MarketItem {
        uint256 itemId;
        address nftContract;
        uint256 tokenId;
        address payable seller;
        address payable owner;
        uint256 price;
        ListingType listingType;
        bool sold;
        uint256 auctionId; // If listing is an auction, reference the auction ID
    }
    
    struct Auction {
        uint256 auctionId;
        uint256 itemId;
        address payable highestBidder;
        uint256 highestBid;
        uint256 startPrice;
        uint256 endTime;
        bool ended;
    }
    
    // Mapping from itemId to MarketItem
    mapping(uint256 => MarketItem) public idToMarketItem;
    
    // Mapping from auctionId to Auction
    mapping(uint256 => Auction) public idToAuction;
    
    // Mapping to track pending withdrawals
    mapping(address => uint256) public pendingWithdrawals;
    
    // Mapping for reserved listings -> listingId -> buyer -> approved
    mapping(uint256 => mapping(address => bool)) private _approvedBuyers;
    
    // Mapping for currency approvals -> listingId -> currency -> price
    mapping(uint256 => mapping(address => uint256)) private _currencyPrices;
    
    // Events
    event MarketItemCreated(
        uint256 indexed itemId,
        address indexed nftContract,
        uint256 indexed tokenId,
        address seller,
        address owner,
        uint256 price,
        ListingType listingType
    );
    
    event MarketItemSold(
        uint256 indexed itemId,
        address indexed nftContract,
        uint256 indexed tokenId,
        address seller,
        address buyer,
        uint256 price
    );
    
    event ListingUpdated(
        uint256 indexed listingId,
        address indexed assetContract,
        address indexed seller
    );
    
    event ListingCancelled(
        uint256 indexed listingId,
        address indexed assetContract,
        address indexed seller
    );
    
    event BuyerApprovedForListing(
        uint256 indexed listingId,
        address indexed buyer,
        bool approved
    );
    
    event CurrencyApprovedForListing(
        uint256 indexed listingId,
        address indexed currency,
        uint256 pricePerToken
    );
    
    modifier whenNotPaused() {
        require(!contractPaused, "Contract is paused");
        _;
    }
    
    constructor() Ownable(msg.sender) {}
    
    /**
     * @dev Emergency pause function
     */
    function toggleContractPause() external onlyOwner {
        contractPaused = !contractPaused;
    }
    
    /**
     * @dev Set marketplace fee
     * @param _fee New fee in basis points
     */
    function setMarketplaceFee(uint256 _fee) external onlyOwner {
        require(_fee <= 1000, "Fee cannot exceed 10%");
        marketplaceFee = _fee;
    }
    
    /**
     * @dev Create a listing with fixed price
     * @param params ListingParameters containing listing details
     */
    function createListing(ListingParameters memory params) 
        external 
        whenNotPaused 
        nonReentrant 
        returns (uint256) 
    {
        require(params.pricePerToken > 0, "Price must be greater than 0");
        require(params.quantity > 0, "Quantity must be greater than 0");
        require(params.quantity == 1, "ERC721 quantity must be 1");
        require(params.startTimestamp < params.endTimestamp, "End time must be after start time");
        
        if (params.startTimestamp == 0) {
            params.startTimestamp = uint128(block.timestamp);
        }
        
        _tokenIds++;
        uint256 itemId = _tokenIds;
        
        idToMarketItem[itemId] = MarketItem(
            itemId,
            params.assetContract,
            params.tokenId,
            payable(msg.sender),
            payable(address(0)), // No owner yet
            params.pricePerToken,
            ListingType.FixedPrice,
            false,
            0 // No auction associated
        );
        
        // Set default currency
        _currencyPrices[itemId][params.currency] = params.pricePerToken;
        
        // Transfer ownership to the marketplace
        IERC721(params.assetContract).transferFrom(msg.sender, address(this), params.tokenId);
        
        emit MarketItemCreated(
            itemId,
            params.assetContract,
            params.tokenId,
            msg.sender,
            address(0),
            params.pricePerToken,
            ListingType.FixedPrice
        );
        
        return itemId;
    }
    
    /**
     * @dev Update an existing listing
     * @param listingId The ID of the listing to update
     * @param params The new listing parameters
     */
    function updateListing(uint256 listingId, ListingParameters memory params) 
        external 
        whenNotPaused 
        nonReentrant 
    {
        MarketItem storage item = idToMarketItem[listingId];
        
        require(item.itemId == listingId, "Listing does not exist");
        require(item.seller == msg.sender, "Not listing creator");
        require(!item.sold, "Listing already sold");
        require(params.pricePerToken > 0, "Price must be greater than 0");
        require(params.quantity == 1, "ERC721 quantity must be 1");
        
        // Update listing
        item.nftContract = params.assetContract;
        item.tokenId = params.tokenId;
        item.price = params.pricePerToken;
        
        // Update currency price
        _currencyPrices[listingId][params.currency] = params.pricePerToken;
        
        emit ListingUpdated(
            listingId,
            params.assetContract,
            msg.sender
        );
    }
    
    /**
     * @dev Cancel a listing
     * @param listingId The ID of the listing to cancel
     */
    function cancelListing(uint256 listingId) 
        external 
        nonReentrant 
    {
        MarketItem storage item = idToMarketItem[listingId];
        
        require(item.itemId == listingId, "Listing does not exist");
        require(msg.sender == item.seller, "Only seller can cancel listing");
        require(!item.sold, "Item already sold");
        require(item.listingType == ListingType.FixedPrice, "Can only cancel fixed price listings");
        
        // Transfer NFT back to seller
        IERC721(item.nftContract).transferFrom(address(this), item.seller, item.tokenId);
        
        emit ListingCancelled(
            listingId,
            item.nftContract,
            item.seller
        );
        
        // Remove item from marketplace
        delete idToMarketItem[listingId];
    }
    
    /**
     * @dev Approve a buyer for a reserved listing
     * @param listingId The ID of the listing
     * @param buyer The address of the buyer to approve
     * @param toApprove Whether to approve or disapprove the buyer
     */
    function approveBuyerForListing(
        uint256 listingId,
        address buyer,
        bool toApprove
    ) external {
        MarketItem storage item = idToMarketItem[listingId];
        
        require(item.itemId == listingId, "Listing does not exist");
        require(msg.sender == item.seller, "Only seller can approve buyers");
        
        _approvedBuyers[listingId][buyer] = toApprove;
        
        emit BuyerApprovedForListing(listingId, buyer, toApprove);
    }
    
    /**
     * @dev Approve a currency for a listing
     * @param listingId The ID of the listing
     * @param currency The currency address to approve
     * @param pricePerTokenInCurrency The price per token in the currency
     */
    function approveCurrencyForListing(
        uint256 listingId,
        address currency,
        uint256 pricePerTokenInCurrency
    ) external {
        MarketItem storage item = idToMarketItem[listingId];
        
        require(item.itemId == listingId, "Listing does not exist");
        require(msg.sender == item.seller, "Only seller can approve currency");
        
        _currencyPrices[listingId][currency] = pricePerTokenInCurrency;
        
        emit CurrencyApprovedForListing(
            listingId,
            currency,
            pricePerTokenInCurrency
        );
    }
    
    /**
     * @dev Buy from a listing
     * @param listingId The ID of the listing to buy from
     * @param buyFor The address to buy for
     * @param quantity The quantity to buy
     * @param currency The currency to pay with
     * @param expectedTotalPrice The expected total price
     */
    function buyFromListing(
        uint256 listingId,
        address buyFor,
        uint256 quantity,
        address currency,
        uint256 expectedTotalPrice
    ) external payable whenNotPaused nonReentrant {
        MarketItem storage item = idToMarketItem[listingId];
        
        require(item.itemId == listingId, "Listing does not exist");
        require(item.listingType == ListingType.FixedPrice, "Item is not for fixed price sale");
        require(!item.sold, "Item already sold");
        require(quantity == 1, "Quantity must be 1 for ERC721");
        
        // Check if currency is approved and get price
        uint256 priceInCurrency = _currencyPrices[listingId][currency];
        require(priceInCurrency > 0, "Currency not accepted for this listing");
        
        // Check total price
        uint256 totalPrice = priceInCurrency * quantity;
        require(totalPrice == expectedTotalPrice, "Unexpected total price");
        
        // If reserved listing, check if buyer is approved
        if (_approvedBuyers[listingId][address(0)]) { // If there's any approved buyer
            require(_approvedBuyers[listingId][msg.sender], "Buyer not approved for reserved listing");
        }
        
        // Handle payment based on currency
        if (currency == NATIVE_TOKEN) {
            require(msg.value == totalPrice, "Incorrect payment amount");
        } else {
            // For ERC20 tokens, would need to implement transfer
            revert("ERC20 payments not implemented");
        }
        
        // Calculate fee
        uint256 fee = (totalPrice * marketplaceFee) / 10000;
        uint256 sellerProceeds = totalPrice - fee;
        
        // Add seller proceeds to pending withdrawals
        pendingWithdrawals[item.seller] += sellerProceeds;
        
        // Transfer NFT to buyer
        IERC721(item.nftContract).transferFrom(address(this), buyFor, item.tokenId);
        
        // Update item state
        item.owner = payable(buyFor);
        item.sold = true;
        _itemsSold++;
        
        emit MarketItemSold(
            listingId,
            item.nftContract,
            item.tokenId,
            item.seller,
            buyFor,
            totalPrice
        );
    }
    
    /**
     * @dev Get total number of listings
     * @return Total number of listings
     */
    function totalListings() external view returns (uint256) {
        return _tokenIds;
    }
    
    /**
     * @dev Get all listings between start and end IDs
     * @param startId Start listing ID (inclusive)
     * @param endId End listing ID (inclusive)
     * @return Array of listings
     */
    function getAllListings(uint256 startId, uint256 endId) 
        external 
        view 
        returns (Listing[] memory) 
    {
        require(startId <= endId, "Invalid range");
        require(endId <= _tokenIds, "End ID exceeds total listings");
        
        uint256 totalItems = endId - startId + 1;
        Listing[] memory listings = new Listing[](totalItems);
        
        for (uint256 i = 0; i < totalItems; i++) {
            uint256 listingId = startId + i;
            MarketItem storage item = idToMarketItem[listingId];
            
            // Skip if item was deleted (cancelled)
            if (item.itemId == 0) {
                continue;
            }
            
            listings[i] = Listing({
                listingId: item.itemId,
                listingCreator: item.seller,
                assetContract: item.nftContract,
                tokenId: item.tokenId,
                quantity: 1, // Always 1 for ERC721
                currency: NATIVE_TOKEN, // Default to native token
                pricePerToken: item.price,
                startTimestamp: 0, // No explicit start time in original contract
                endTimestamp: type(uint128).max, // No explicit end time
                reserved: _approvedBuyers[listingId][address(0)], // If there's any approved buyer
                tokenType: TokenType.ERC721,
                status: item.sold ? Status.COMPLETED : Status.CREATED
            });
        }
        
        return listings;
    }
    
    /**
     * @dev Get all valid listings between start and end IDs
     * @param startId Start listing ID (inclusive)
     * @param endId End listing ID (inclusive)
     * @return Array of valid listings
     */
    function getAllValidListings(uint256 startId, uint256 endId) 
        external 
        view 
        returns (Listing[] memory) 
    {
        require(startId <= endId, "Invalid range");
        require(endId <= _tokenIds, "End ID exceeds total listings");
        
        uint256 validCount = 0;
        
        // First, count valid listings
        for (uint256 i = startId; i <= endId; i++) {
            MarketItem storage item = idToMarketItem[i];
            if (item.itemId != 0 && !item.sold) {
                validCount++;
            }
        }
        
        Listing[] memory validListings = new Listing[](validCount);
        uint256 currentIndex = 0;
        
        // Fill array with valid listings
        for (uint256 i = startId; i <= endId; i++) {
            MarketItem storage item = idToMarketItem[i];
            
            if (item.itemId != 0 && !item.sold) {
                validListings[currentIndex] = Listing({
                    listingId: item.itemId,
                    listingCreator: item.seller,
                    assetContract: item.nftContract,
                    tokenId: item.tokenId,
                    quantity: 1, // Always 1 for ERC721
                    currency: NATIVE_TOKEN, // Default to native token
                    pricePerToken: item.price,
                    startTimestamp: 0, // No explicit start time in original contract
                    endTimestamp: type(uint128).max, // No explicit end time
                    reserved: _approvedBuyers[i][address(0)], // If there's any approved buyer
                    tokenType: TokenType.ERC721,
                    status: Status.CREATED
                });
                currentIndex++;
            }
        }
        
        return validListings;
    }
    
    /**
     * @dev Get a specific listing
     * @param listingId The ID of the listing to fetch
     * @return The listing data
     */
    function getListing(uint256 listingId) 
        external 
        view 
        returns (Listing memory) 
    {
        MarketItem storage item = idToMarketItem[listingId];
        require(item.itemId == listingId, "Listing does not exist");
        
        return Listing({
            listingId: item.itemId,
            listingCreator: item.seller,
            assetContract: item.nftContract,
            tokenId: item.tokenId,
            quantity: 1, // Always 1 for ERC721
            currency: NATIVE_TOKEN, // Default to native token
            pricePerToken: item.price,
            startTimestamp: 0, // No explicit start time in original contract
            endTimestamp: type(uint128).max, // No explicit end time
            reserved: _approvedBuyers[listingId][address(0)], // If there's any approved buyer
            tokenType: TokenType.ERC721,
            status: item.sold ? Status.COMPLETED : Status.CREATED
        });
    }
}